/*
Найти след матрицы,  след матрицы — сумма элементов главной диагонали. Размер матрицы вводит пользователь, матрицу заполнять случайными числами.

Для начала, чтобы хотя-бы представлять у себя в голове решение данной программы, давайте научимся работать с двумерными массивами в С++. На  этап сложнее будет использование в программе динамических массивов.

С массивами мы разобрались, а вот каким же образом генерировать случайные числа? Перейдите по ссылке, там подробно описан этот процесс. Также можно почитать справочник по функции rand, в котором даже есть пример исходного кода.
*/

#include <iostream>
#include <cstdlib>  // Для rand() и srand()
#include <ctime>    // Для time()

using namespace std;

int main() {
    int rows, cols;

    // Ввод размеров матрицы
    cout << "Введите количество строк матрицы: ";
    cin >> rows;
    cout << "Введите количество столбцов матрицы: ";
    cin >> cols;

    // Проверка на квадратную матрицу
    if (rows != cols) {
        cout << "Для вычисления следа матрицы требуется квадратная матрица!" << endl;
        return 1;
    }

    // Создание динамического массива для матрицы
    int** matrix = new int*[rows];
    for (int i = 0; i < rows; ++i) {
        matrix[i] = new int[cols];
    }

    // Инициализация генератора случайных чисел
    srand(static_cast<unsigned int>(time(0)));

    // Заполнение матрицы случайными числами и вывод её на экран
    cout << "Сгенерированная матрица:" << endl;
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
            matrix[i][j] = rand() % 100; // Генерация случайного числа от 0 до 99
            cout << matrix[i][j] << "\t"; // Вывод элемента матрицы
        }
        cout << endl; // Переход на новую строку
    }

    // Вычисление следа матрицы
    int trace = 0;
    for (int i = 0; i < rows; ++i) {
        trace += matrix[i][i]; // Суммирование элементов главной диагонали
    }

    // Вывод результата
    cout << "След матрицы: " << trace << endl;

    // Освобождение памяти
    for (int i = 0; i < rows; ++i) {
        delete[] matrix[i]; // Освобождение каждой строки
    }
    delete[] matrix; // Освобождение массива строк

    return 0;
}
